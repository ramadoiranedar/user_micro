// Code generated by go-swagger; DO NOT EDIT.

package main

import (
	"log"
	"os"

	"github.com/go-openapi/loads"
	"github.com/go-openapi/swag"
	flags "github.com/jessevdk/go-flags"
	"github.com/sirupsen/logrus"

	"github.com/ramadoiranedar/user_micro"
	"github.com/ramadoiranedar/user_micro/gen/restapi"
	"github.com/ramadoiranedar/user_micro/gen/restapi/operations"
	"github.com/ramadoiranedar/user_micro/internal/handlers"
	"github.com/ramadoiranedar/user_micro/internal/repositories"
	"github.com/ramadoiranedar/user_micro/internal/routes"
	"github.com/ramadoiranedar/user_micro/internal/usecases"
	"github.com/ramadoiranedar/user_micro/internal/utilities"
)

// This file was generated by the swagger tool.
// Make sure not to overwrite this file after you generated it because all your edits would be lost!

var configureFlags struct {
	Config string `long:"config" description:"Main application configuration YAML path"`
}

func main() {
	logger := utilities.NewLogger()
	swaggerSpec, err := loads.Embedded(restapi.SwaggerJSON, restapi.FlatSwaggerJSON)
	if err != nil {
		log.Fatalln(err)
	}

	api, server, parser := setupAPI(logger, swaggerSpec)
	defer server.Shutdown()

	if _, err := parser.Parse(); err != nil {
		handleCommandLineError(err)
	}

	config := utilities.NewConfiguration(logger, configureFlags.Config)
	runtime := user_micro.NewRuntime(config, logger)
	defer runtime.Close()
	defer server.Shutdown()

	repositories := repositories.NewRepositories(repositories.RepositoriesDTO{
		Logger: runtime.Logger(),
		Config: runtime.Config(),
		Database: runtime.Database(),
	})

	usecases := usecases.NewUsecases(usecases.UsecasesDTO{
		Logger: runtime.Logger(),
		Config: runtime.Config(),
		Repositories: repositories,
	})

	handlers := handlers.NewHandlers(handlers.HandlersDTO{
		Logger: runtime.Logger(),
		Config: runtime.Config(),
		Usecases: usecases,
	})

	utilities.SetAuthorization(utilities.AuthorizationDTO{
		Logger: runtime.Logger(),
		Config: runtime.Config(),
		Api: api,
	})

	routes.SetRoutes(routes.RoutesDTO{
		Logger: runtime.Logger(),
		Config: runtime.Config(),
		Api: api,
		Handlers: handlers,
	})

	server.ConfigureAPI()
	if err := server.Serve(); err != nil {
		log.Fatalln(err)
	}
}

func setupAPI(logger logrus.FieldLogger, swaggerSpec *loads.Document) (*operations.UserMicroServerAPI, *restapi.Server, *flags.Parser) {
	api := operations.NewUserMicroServerAPI(swaggerSpec)
	api.Logger = logger.Infof
	api.CommandLineOptionsGroups = []swag.CommandLineOptionsGroup{
		{
			ShortDescription: "APP Flags",
			Options:          &configureFlags,
		},
	}

	server := restapi.NewServer(api)

	parser := flags.NewParser(server, flags.Default)
	parser.ShortDescription = "REST API for TERASEHAT User Microservice"
	parser.LongDescription = "The \"REST API for TERASEHAT User Microservice\" refers to the Representational State Transfer (REST) Application Programming Interface (API) specifically tailored for the User Microservice within TERASEHAT. This API facilitates communication and interaction with the User Microservice, allowing external applications or services to execute operations related to user management within the TERASEHAT system. The API includes endpoints for user registration, authentication, and other user-related functionalities, following RESTful principles to ensure scalability and interoperability as a web service for the TERASEHAT platform."
	server.ConfigureFlags()

	for _, optsGroup := range api.CommandLineOptionsGroups {
		_, err := parser.AddGroup(optsGroup.ShortDescription, "", optsGroup.Options)
		if err != nil {
			log.Fatalln(err)
		}
	}

	return api, server, parser
}

func handleCommandLineError(err error) {
	code := 1
	if fe, ok := err.(*flags.Error); ok && fe.Type == flags.ErrHelp {
		code = 0
	}
	os.Exit(code)
}